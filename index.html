<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Neon Games Hub</title>

<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#050608">

<style>
:root{
  --bg:#050608;
  --neon:#00ff95;
  --danger:#ff0066;
  --soft:rgba(0,255,150,.25);
  --text:#eafff6;
}

*{box-sizing:border-box}

body{
  margin:0;
  background:radial-gradient(circle at top,#0d151b,#050608 70%);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text);
  overflow:hidden;
}

/* ===== HUB ===== */
#topbar{
  display:flex;
  align-items:center;
  gap:14px;
  padding:16px;
  border-bottom:1px solid var(--soft);
}

#logo{
  width:40px;height:40px;
  border-radius:10px;
  background:linear-gradient(135deg,var(--neon),#00c27a);
  display:grid;place-items:center;
  font-weight:900;color:#022;
}

#content{
  height:calc(100vh - 72px);
  overflow-y:auto;
  padding:16px;
}

.grid{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(180px,1fr));
  gap:16px;
}

.card{
  background:#0b141a;
  border:1px solid var(--soft);
  border-radius:16px;
  padding:14px;
  display:flex;
  flex-direction:column;
  gap:12px;
}

.card h3{margin:0;color:var(--neon)}
.play{
  margin-top:auto;
  padding:12px;
  border-radius:14px;
  border:1px solid var(--soft);
  background:#050608;
  color:var(--text);
  cursor:pointer;
}

/* ===== GAME OVERLAY ===== */
#overlay{
  position:fixed;
  inset:0;
  background:#050608;
  display:none;
  z-index:1000;
}

canvas{display:block}

/* ===== TOUCH CONTROLS ===== */
#controls{
  position:fixed;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  display:none;
  gap:10px;
}

.ctrl{
  width:60px;height:60px;
  border-radius:50%;
  background:rgba(0,255,150,.15);
  border:1px solid var(--soft);
  display:grid;place-items:center;
  font-size:22px;
}
</style>
</head>
<body>

<div id="topbar">
  <div id="logo">N</div>
  <strong>Neon Games Hub</strong>
</div>

<div id="content">
  <div class="grid" id="grid"></div>
</div>

<div id="overlay">
  <canvas id="game"></canvas>
  <div id="controls">
    <div class="ctrl" data-k="ArrowLeft">◀</div>
    <div class="ctrl" data-k="ArrowRight">▶</div>
    <div class="ctrl" data-k="ArrowUp">▲</div>
    <div class="ctrl" data-k="ArrowDown">▼</div>
  </div>
</div>

<script>
/* ================= HUB ================= */
const games=[
  {id:"snake",name:"Snake"},
  {id:"tetris",name:"Tetris"},
  {id:"platformer",name:"Platformer"},
  {id:"tower",name:"Tower Defense"}
];

const grid=document.getElementById("grid");
const overlay=document.getElementById("overlay");
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const controls=document.getElementById("controls");
const keys={};

games.forEach(g=>{
  const c=document.createElement("div");
  c.className="card";
  c.innerHTML=`<h3>${g.name}</h3><button class="play">Play</button>`;
  c.querySelector(".play").onclick=()=>startGame(g.id);
  grid.appendChild(c);
});

function resize(){
  canvas.width=innerWidth;
  canvas.height=innerHeight;
}
window.addEventListener("resize",resize);

/* ================= INPUT ================= */
window.addEventListener("keydown",e=>{
  keys[e.key]=true;
  if(e.key==="Escape") exitGame();
});
window.addEventListener("keyup",e=>keys[e.key]=false);

document.querySelectorAll(".ctrl").forEach(b=>{
  b.ontouchstart=()=>keys[b.dataset.k]=true;
  b.ontouchend=()=>keys[b.dataset.k]=false;
});

/* ================= ENGINE ================= */
let game=null;

function startGame(id){
  resize();
  overlay.style.display="block";
  controls.style.display="flex";
  game=Games[id];
  game.init();
  loop();
}

function exitGame(){
  overlay.style.display="none";
  controls.style.display="none";
  game=null;
}

function loop(){
  if(!game) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  game.update();
  game.draw();
  requestAnimationFrame(loop);
}

/* ================= GAMES ================= */
const Games={

  snake:{
    init(){
      this.s=20;
      this.sn=[{x:10,y:10}];
      this.d={x:1,y:0};
      this.f={x:15,y:15};
      this.t=0;
    },
    update(){
      if(++this.t<6) return;
      this.t=0;
      if(keys.ArrowUp) this.d={x:0,y:-1};
      if(keys.ArrowDown) this.d={x:0,y:1};
      if(keys.ArrowLeft) this.d={x:-1,y:0};
      if(keys.ArrowRight) this.d={x:1,y:0};
      const h={x:this.sn[0].x+this.d.x,y:this.sn[0].y+this.d.y};
      if(h.x<0||h.y<0||h.x>canvas.width/this.s||h.y>canvas.height/this.s) return exitGame();
      this.sn.unshift(h);
      if(h.x===this.f.x&&h.y===this.f.y){
        this.f={x:Math.random()*20|0,y:Math.random()*20|0};
      } else this.sn.pop();
    },
    draw(){
      ctx.fillStyle=varNeon;
      this.sn.forEach(s=>ctx.fillRect(s.x*this.s,s.y*this.s,this.s-2,this.s-2));
      ctx.fillStyle=varDanger;
      ctx.fillRect(this.f.x*this.s,this.f.y*this.s,this.s-2,this.s-2);
    }
  },

  tetris:{
    init(){
      this.y=0;
    },
    update(){
      this.y+=2;
      if(this.y>canvas.height) exitGame();
    },
    draw(){
      ctx.fillStyle=varNeon;
      ctx.fillRect(canvas.width/2-20,this.y,40,40);
    }
  },

platformer:{
  init(){
    // tile size
    this.T = 32;

    // player
    this.p = {
      x: 64,
      y: 64,
      w: 28,
      h: 28,
      vx: 0,
      vy: 0,
      onGround: false
    };

    // physics
    this.gravity = 0.9;
    this.jumpPower = -15;
    this.moveSpeed = 4;

    // level map (0 = empty, 1 = block, 2 = spikes)
    this.map = [
      "00000000000000000000",
      "00000000000000000000",
      "00000000000000000000",
      "00000111100000000000",
      "00000000000000011100",
      "00011100000000000000",
      "00000000000011100000",
      "00000000000000000000",
      "11111111111111111111",
      "11111111111111111111"
    ];

    this.rows = this.map.length;
    this.cols = this.map[0].length;
  },

  update(){
    const p = this.p;

    // horizontal input
    if(keys.ArrowLeft) p.vx = -this.moveSpeed;
    else if(keys.ArrowRight) p.vx = this.moveSpeed;
    else p.vx = 0;

    // jump
    if(keys.ArrowUp && p.onGround){
      p.vy = this.jumpPower;
      p.onGround = false;
    }

    // gravity
    p.vy += this.gravity;

    // apply movement
    p.x += p.vx;
    this.resolveCollisions("x");

    p.y += p.vy;
    this.resolveCollisions("y");
  },

  resolveCollisions(axis){
    const p = this.p;
    const T = this.T;

    p.onGround = false;

    // tile range to check
    const left   = Math.floor(p.x / T);
    const right  = Math.floor((p.x + p.w) / T);
    const top    = Math.floor(p.y / T);
    const bottom = Math.floor((p.y + p.h) / T);

    for(let y = top; y <= bottom; y++){
      for(let x = left; x <= right; x++){
        const tile = this.map[y]?.[x];
        if(!tile) continue;

        const tx = x * T;
        const ty = y * T;

        // solid block
        if(tile === "1"){
          if(
            p.x < tx + T &&
            p.x + p.w > tx &&
            p.y < ty + T &&
            p.y + p.h > ty
          ){
            if(axis === "x"){
              if(p.vx > 0) p.x = tx - p.w;
              if(p.vx < 0) p.x = tx + T;
              p.vx = 0;
            }

            if(axis === "y"){
              if(p.vy > 0){
                p.y = ty - p.h;
                p.vy = 0;
                p.onGround = true;
              }
              if(p.vy < 0){
                p.y = ty + T;
                p.vy = 0;
              }
            }
          }
        }

        // spikes
        if(tile === "2"){
          if(
            p.x < tx + T &&
            p.x + p.w > tx &&
            p.y < ty + T &&
            p.y + p.h > ty
          ){
            // restart level
            this.init();
          }
        }
      }
    }
  },

  draw(){
    // background
    ctx.fillStyle = "#050608";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw tiles
    for(let y=0;y<this.rows;y++){
      for(let x=0;x<this.cols;x++){
        const tile = this.map[y][x];
        const tx = x * this.T;
        const ty = y * this.T;

        // block
        if(tile === "1"){
          ctx.fillStyle = "#2a2a2a";
          ctx.fillRect(tx,ty,this.T,this.T);
        }

        // spikes
        if(tile === "2"){
          ctx.fillStyle = "#ff0066";
          ctx.beginPath();
          ctx.moveTo(tx, ty + this.T);
          ctx.lineTo(tx + this.T/2, ty);
          ctx.lineTo(tx + this.T, ty + this.T);
          ctx.fill();
        }
      }
    }

    // player (neon glow)
    ctx.shadowBlur = 20;
    ctx.shadowColor = "#00ff95";
    ctx.fillStyle = "#00ff95";
    ctx.fillRect(this.p.x,this.p.y,this.p.w,this.p.h);
    ctx.shadowBlur = 0;
  }
};

const varNeon="#00ff95";
const varDanger="#ff0066";
</script>

<script>
if("serviceWorker"in navigator){
  navigator.serviceWorker.register("/service-worker.js");
}
</script>

</body>
</html>
